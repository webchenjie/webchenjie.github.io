---
title: 0.1 + 0.2 !== 0.3
date: 2020-09-11
tags:
    - JavaScript
categories:
    - 技术
publish: true
---

## IEEE 754 计算步骤

1. 指数对阶
    1. 小阶对大阶，会右移，容易丢失位数
    2. 相加或相减，值可以溢出
2. 尾数运算
    1. 尾数运算就是在完成对阶以后进行尾数相加减
3. 结果规格化
    1. 左移规格化，右移可能精度丢失
4. 舍入处理
    1. 四舍五入，1 入 0 舍（默认）
    2. 朝正无穷方向舍入
    3. 朝负无穷方向舍入
    4. 朝 0 方向舍入
5. 溢出检查
    1. 运算结果的阶码的值判断是否溢出
    2. 超过最大正数（上溢）：浮点数正数是正上溢，否则是负上溢

## 双精度 64 举例

1. 符号位（1 位）+ 指数位（11 位）+ 尾数（52 位）
2. 符号位中，1 表示负数，0 表示正数
3. 指数位中，指数 = 指数 + 1023（偏移码）
4. 尾数中，默认存储 1 后面部分，小数部分

## 0.1 + 0.2 !== 0.3

1. js 采用的是 IEEE 754 标准，其中有俩个标准一种是 64 位双精度浮点数，一种是 32 为单精度浮点数
   这俩种标准主要的区别在于数的范围的大小
2. 32 位的尾数一共 23 个字符。最多表示 23 个 1 也就是数字 2^23(8388608)。当值大于这个数的时候就会超过 23 位
   因此就没法计算了。（64 位也是相同的道理）
3. 在计算的时候并不是先将 10 进制数计算完成在存储为 2 进制。而是会先将 10 进制转换为二进制在计算
4. 0.1 或 0.2 在转换二进制数时是个无限循环小数，会出现小数丢失情况，所以 0.1 + 0.2 !== 0.3

5. 原因：存储、运算、显示

    1. 存储：十进制数字转二进制可能是无限循环的，所以存不下，会进行舍去或加，比如 0.2 转二进制实际上是比 0.2 大的，而 0.3 转二进制是比 0.3 小的
    2. 运算：会把上述问题的存储问题放大或修复，比如 0.2 + 0.3 = 0.5，刚好一个偏大一个偏小正好修复了，再比如 0.3 - 0.2 !== 0.1，这个就放大了
    3. 显示：做了近似处理，比如 0.3 存储的二进制是偏小的，但是在控制输入 0.3 时是显示 0.3，而不是 0.299999999...，但是你如果使用 0.3 === 2.99999，就是 true，可以使用 0.3.toPrecision(30) 获取二进制的值

6. 基于以上的问题，toFixed() 这个函数也有问题
    1. 比如 1.45.toFixed(1) === 1.4
       2.45.toFixed(1) === 2.5
       还是因为存储精度截取问题，如果最后一位的二进制是 1 则得到的二进制就会进 1 导致偏大，如果是 0 则会舍去导致偏小

::: tip
作者：chenjie <br>
链接：https://webchenjie.cn <br>
来源：ChenJieBlog
:::
