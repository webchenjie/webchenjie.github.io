(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{472:function(v,a,t){"use strict";t.r(a);var _=t(2),e=Object(_.a)({},(function(){var v=this,a=v._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[a("h2",{attrs:{id:"v-show-和-v-if-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#v-show-和-v-if-的区别"}},[v._v("#")]),v._v(" v-show 和 v-if 的区别？")]),v._v(" "),a("ol",[a("li",[v._v("v-show 通过 css display 控制显示和隐藏")]),v._v(" "),a("li",[v._v("v-if 组件真正的渲染和销毁,而不是显示和隐藏")]),v._v(" "),a("li",[v._v("频繁的切换显示状态用 v-show,否则用 v-if")])]),v._v(" "),a("h2",{attrs:{id:"为何在-v-for-中用-key"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为何在-v-for-中用-key"}},[v._v("#")]),v._v(" 为何在 v-for 中用 key？")]),v._v(" "),a("ol",[a("li",[v._v("必须用 key,且不能是 index 和随机数")]),v._v(" "),a("li",[v._v("diff 算法中通过 tag 和 key 来判断,是否是 sameNode")]),v._v(" "),a("li",[v._v("减少渲染次数,提升渲染性能")])]),v._v(" "),a("h2",{attrs:{id:"vue-组件如何通讯-常见"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-组件如何通讯-常见"}},[v._v("#")]),v._v(" vue 组件如何通讯,常见？")]),v._v(" "),a("ol",[a("li",[v._v("父子组件 props 和 this.$emit")]),v._v(" "),a("li",[v._v("自定义事件 event.$on、event.$off、event.$emit （总线 bus）")]),v._v(" "),a("li",[v._v("$attrs")]),v._v(" "),a("li",[v._v("provide/inject")]),v._v(" "),a("li",[v._v("$ref")]),v._v(" "),a("li",[v._v("$parent")]),v._v(" "),a("li",[v._v("vuex")])]),v._v(" "),a("h2",{attrs:{id:"双向数据绑定-v-model-的实现原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#双向数据绑定-v-model-的实现原理"}},[v._v("#")]),v._v(" 双向数据绑定 v-model 的实现原理？")]),v._v(" "),a("ol",[a("li",[v._v("input 元素的 value = this.name")]),v._v(" "),a("li",[v._v("绑定 input 事件 this.name = $event.target.value")]),v._v(" "),a("li",[v._v("data 更新触发 re-render")])]),v._v(" "),a("h2",{attrs:{id:"对-mvvm-的理解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对-mvvm-的理解"}},[v._v("#")]),v._v(" 对 MVVM 的理解？")]),v._v(" "),a("ol",[a("li",[v._v("M: Model 层,即数据库")]),v._v(" "),a("li",[v._v("V: View 层,即视图层 DOM")]),v._v(" "),a("li",[v._v("VM: 即 Vue")])]),v._v(" "),a("h2",{attrs:{id:"computed-有何特点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#computed-有何特点"}},[v._v("#")]),v._v(" computed 有何特点？")]),v._v(" "),a("ol",[a("li",[v._v("有缓存,data 不变不会重新计算")]),v._v(" "),a("li",[v._v("提高性能")])]),v._v(" "),a("h2",{attrs:{id:"为何组件-data-必须是一个函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为何组件-data-必须是一个函数"}},[v._v("#")]),v._v(" 为何组件 data 必须是一个函数？")]),v._v(" "),a("ol",[a("li",[v._v("vue 文件最后编译出来是一个 class")]),v._v(" "),a("li",[v._v("只有 data 是一个函数才能做到在不同的地方使用时 data 数据不共享")])]),v._v(" "),a("h2",{attrs:{id:"ajax-请求应该放在哪个生命周期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ajax-请求应该放在哪个生命周期"}},[v._v("#")]),v._v(" ajax 请求应该放在哪个生命周期？")]),v._v(" "),a("ol",[a("li",[v._v("mounted")]),v._v(" "),a("li",[v._v("js 是单线程,ajax 异步获取数据")]),v._v(" "),a("li",[v._v("放在 mounted 之前是没有用的,只会让逻辑更加混乱")])]),v._v(" "),a("h2",{attrs:{id:"如何将组件所有-props-传递给子组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何将组件所有-props-传递给子组件"}},[v._v("#")]),v._v(" 如何将组件所有 props 传递给子组件？")]),v._v(" "),a("ol",[a("li",[v._v('<组件名 v-bind="$props" />')])]),v._v(" "),a("h2",{attrs:{id:"多个组件有相同的逻辑-如何抽离"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#多个组件有相同的逻辑-如何抽离"}},[v._v("#")]),v._v(" 多个组件有相同的逻辑,如何抽离？")]),v._v(" "),a("ol",[a("li",[v._v("mixin")])]),v._v(" "),a("h2",{attrs:{id:"何时要使用异步组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#何时要使用异步组件"}},[v._v("#")]),v._v(" 何时要使用异步组件？")]),v._v(" "),a("ol",[a("li",[v._v("加载大组件")]),v._v(" "),a("li",[v._v("路由异步加载")]),v._v(" "),a("li",[v._v("优化性能")])]),v._v(" "),a("h2",{attrs:{id:"何时需要使用-keep-alive"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#何时需要使用-keep-alive"}},[v._v("#")]),v._v(" 何时需要使用 keep-alive？")]),v._v(" "),a("ol",[a("li",[v._v("缓存组件,不需要重复渲染")]),v._v(" "),a("li",[v._v("如多个静态 tab 页的切换")]),v._v(" "),a("li",[v._v("优化性能")])]),v._v(" "),a("h2",{attrs:{id:"何时需要使用-beforedestory"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#何时需要使用-beforedestory"}},[v._v("#")]),v._v(" 何时需要使用 beforeDestory？")]),v._v(" "),a("ol",[a("li",[v._v("解绑自定义事件 evnet.$off")]),v._v(" "),a("li",[v._v("清除定时器")]),v._v(" "),a("li",[v._v("解绑自定义的 DOM 事件,如 window.scroll 等")]),v._v(" "),a("li",[v._v("vue 事件会自动解除,自定义则需要自己解除")])]),v._v(" "),a("h2",{attrs:{id:"vuex-中-action-和-mutation-有区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vuex-中-action-和-mutation-有区别"}},[v._v("#")]),v._v(" vuex 中 action 和 mutation 有区别？")]),v._v(" "),a("ol",[a("li",[v._v("action 中处理异步,mutation 不可以")]),v._v(" "),a("li",[v._v("mutation 做原子操作")]),v._v(" "),a("li",[v._v("action 可以整合多个 mutation")])]),v._v(" "),a("h2",{attrs:{id:"vue-router-常用的路由模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-router-常用的路由模式"}},[v._v("#")]),v._v(" vue-router 常用的路由模式？")]),v._v(" "),a("ol",[a("li",[v._v("hash 默认\n"),a("ol",[a("li",[v._v("实现原理：window.location.hash")])])]),v._v(" "),a("li",[v._v("H5 history 需要服务端支持\n"),a("ol",[a("li",[v._v("实现原理：window.history.pushState 推送路由 + window.onpopstate 监听路由变化")])])]),v._v(" "),a("li",[v._v("abstract history，Vue3 改名为 memory history，即 url 不会发生变化，没有前进后退")])]),v._v(" "),a("h2",{attrs:{id:"如何配置-vue-router-异步加载"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何配置-vue-router-异步加载"}},[v._v("#")]),v._v(" 如何配置 vue-router 异步加载？")]),v._v(" "),a("ol",[a("li",[v._v("使用函数返回 import")]),v._v(" "),a("li",[v._v("component: () => import('路径')")])]),v._v(" "),a("h2",{attrs:{id:"请用-vnode-描述一个-dom-结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#请用-vnode-描述一个-dom-结构"}},[v._v("#")]),v._v(" 请用 vnode 描述一个 DOM 结构？")]),v._v(" "),a("ol",[a("li",[v._v("看上面 vdom")])]),v._v(" "),a("h2",{attrs:{id:"监听-data-变化的核心-api-是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#监听-data-变化的核心-api-是什么"}},[v._v("#")]),v._v(" 监听 data 变化的核心 API 是什么？")]),v._v(" "),a("ol",[a("li",[v._v("Object.defineProperty")]),v._v(" "),a("li",[v._v("以及深度监听、监听数组")]),v._v(" "),a("li",[v._v("具体看上面响应式")])]),v._v(" "),a("h2",{attrs:{id:"vue-如何监听数组变化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-如何监听数组变化"}},[v._v("#")]),v._v(" vue 如何监听数组变化？")]),v._v(" "),a("ol",[a("li",[v._v("Object.defineProperty 不能监听数组变化")]),v._v(" "),a("li",[v._v("重新定义原型,重写 push、pop 等方法,实现监听")]),v._v(" "),a("li",[v._v("具体看上面响应式")])]),v._v(" "),a("h2",{attrs:{id:"请描述响应式原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#请描述响应式原理"}},[v._v("#")]),v._v(" 请描述响应式原理？")]),v._v(" "),a("ol",[a("li",[v._v("监听 data 变化")]),v._v(" "),a("li",[v._v("组件渲染和更新的流程")])]),v._v(" "),a("h2",{attrs:{id:"diff-算法的时间复杂度"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#diff-算法的时间复杂度"}},[v._v("#")]),v._v(" diff 算法的时间复杂度？")]),v._v(" "),a("ol",[a("li",[v._v("O(n)")]),v._v(" "),a("li",[v._v("在 O(n^3)基础上做了一下调整")])]),v._v(" "),a("h2",{attrs:{id:"简述-diff-算法过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#简述-diff-算法过程"}},[v._v("#")]),v._v(" 简述 diff 算法过程？")]),v._v(" "),a("ol",[a("li",[v._v("patch(ele, vnode)和 patch(oldVnode, newVnode)")]),v._v(" "),a("li",[v._v("patchVnode 和 addVnodes 和 removeVnodes")]),v._v(" "),a("li",[v._v("updatechildren // key 的重要性")])]),v._v(" "),a("h2",{attrs:{id:"vue2、vue3、react-三者-diff-算法的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue2、vue3、react-三者-diff-算法的区别"}},[v._v("#")]),v._v(" Vue2、Vue3、React 三者 diff 算法的区别？")]),v._v(" "),a("ol",[a("li",[v._v("Vue2 - 双端比较")]),v._v(" "),a("li",[v._v("Vue3 - 在 Vue2 的基础上，增加最长递增子序列")]),v._v(" "),a("li",[v._v("React - 仅右移")])]),v._v(" "),a("h2",{attrs:{id:"vue-为何是异步渲染-nexttick-何用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-为何是异步渲染-nexttick-何用"}},[v._v("#")]),v._v(" vue 为何是异步渲染,$nextTick 何用？")]),v._v(" "),a("ol",[a("li",[v._v("异步渲染(以及合并 data 修改),以提高渲染性能")]),v._v(" "),a("li",[v._v("$nextTick 在 DOM 更新完之后,触发回调")])]),v._v(" "),a("h2",{attrs:{id:"vue-常见性能优化方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-常见性能优化方式"}},[v._v("#")]),v._v(" vue 常见性能优化方式？")]),v._v(" "),a("ol",[a("li",[v._v("合理使用 v-show 和 v-if")]),v._v(" "),a("li",[v._v("合理使用 computed")]),v._v(" "),a("li",[a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[v._v("   v-for时加key,以及避免和v-if同时使用\n")])])])]),v._v(" "),a("li",[v._v("自定义事件、DOM 事件及时销毁")]),v._v(" "),a("li",[v._v("合理使用异步组件")]),v._v(" "),a("li",[v._v("合理使用 keep-alive")]),v._v(" "),a("li",[v._v("data 层级不要太深")]),v._v(" "),a("li",[v._v("使用 vue-loader 在开发环境做模板编译 （预编译）")]),v._v(" "),a("li",[v._v("webpack 层面的优化")]),v._v(" "),a("li",[v._v("前端通用的性能优化,如图片懒加载 （具体看 js 的性能和安全）")]),v._v(" "),a("li",[v._v("使用 SSR")])]),v._v(" "),a("h2",{attrs:{id:"data-状态设计和组件设计"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#data-状态设计和组件设计"}},[v._v("#")]),v._v(" data 状态设计和组件设计？")]),v._v(" "),a("ol",[a("li",[v._v("data 状态设计:\n"),a("ol",[a("li",[v._v("用数据描述所有内容")]),v._v(" "),a("li",[v._v("数据要结构化,易于程序操作(遍历、查找)")]),v._v(" "),a("li",[v._v("数据要可扩展,以便增加新的功能")])])]),v._v(" "),a("li",[v._v("组件设计:\n"),a("ol",[a("li",[v._v("从功能上拆分层次")]),v._v(" "),a("li",[v._v("尽量让组件原子化")]),v._v(" "),a("li",[v._v("容器组件(只管理数据)")]),v._v(" "),a("li",[v._v("UI 组件(只显示视图)")])])])]),v._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"title"}),a("p",[v._v("作者：chenjie "),a("br"),v._v("\n链接：https://webchenjie.cn "),a("br"),v._v("\n来源：ChenJieBlog")])])])}),[],!1,null,null,null);a.default=e.exports}}]);