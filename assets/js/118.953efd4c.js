(window.webpackJsonp=window.webpackJsonp||[]).push([[118],{546:function(t,e,r){"use strict";r.r(e);var a=r(2),s=Object(a.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"简介"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[t._v("#")]),t._v(" 简介")]),t._v(" "),e("p",[t._v("使用 proxy 创建代理对象，在生成时做了 WeakMap 的缓存，如果有则直接返回，没有则创建后缓存，最后返回 proxy 实例")]),t._v(" "),e("h2",{attrs:{id:"过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#过程"}},[t._v("#")]),t._v(" 过程")]),t._v(" "),e("p",[t._v("getter 和 setter 配合 Reflect 进行 get 和 set 操作，在 get 时进行 track 即依赖收集，在 set 时进行 trigger 即依赖触发")]),t._v(" "),e("h2",{attrs:{id:"缺陷"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缺陷"}},[t._v("#")]),t._v(" 缺陷")]),t._v(" "),e("ul",[e("li",[t._v("reactive 只能对复杂数据类型进行使用，没办法使用简单数据类型，所以有 ref")]),t._v(" "),e("li",[t._v("reactive 的响应性数据，不可以进行解构，因为解构之后的数据就不是 proxy 实例，从而也就不是响应式数据了\n"),e("ul",[e("li",[t._v("toRef")]),t._v(" "),e("li",[t._v("toRefs")])])])])])}),[],!1,null,null,null);e.default=s.exports}}]);