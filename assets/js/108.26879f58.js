(window.webpackJsonp=window.webpackJsonp||[]).push([[108],{592:function(e,t,a){"use strict";a.r(t);var v=a(2),_=Object(v.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"简介"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[e._v("#")]),e._v(" 简介")]),e._v(" "),t("p",[e._v("创建 RefImpl 实例，然后返回，在创建时判断了当前是否是 ref 类型数据，如果是则直接返回，不是再去创建")]),e._v(" "),t("blockquote",[t("p",[e._v("判断是否是 ref 对象是通过对象中的 __v_isRef 这个属性进行判断，这个值是个 boolean")])]),e._v(" "),t("h2",{attrs:{id:"过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#过程"}},[e._v("#")]),e._v(" 过程")]),e._v(" "),t("ul",[t("li",[e._v("复杂类型")])]),e._v(" "),t("p",[e._v("如果是复杂类型则直接调用 reactive 进行创建响应式赋值给 RefImpl 中的 _value")]),e._v(" "),t("ul",[t("li",[e._v("简单类型")])]),e._v(" "),t("p",[e._v("如果是简单类型则是直接使用 class 中的 getter 和 setter 属性进行创建的，其实没有响应式，需要用户手动触发 .value 的访问从而触发 get 和 set 的操作")]),e._v(" "),t("h2",{attrs:{id:"依赖收集和触发"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#依赖收集和触发"}},[e._v("#")]),e._v(" 依赖收集和触发")]),e._v(" "),t("p",[e._v("RefImpl 中有个 dep 属性，对应的是一个 Set 对象，对应的 ReactiveEffect 依赖就存放在这里，这里的依赖没有 WeakMap 缓存")]),e._v(" "),t("ul",[t("li",[e._v("复杂类型")])]),e._v(" "),t("p",[e._v("如果是复杂类型则会触发两个依赖收集，一个是 ref 本身的 get 和 set，一个是 reactive 中的 get 和 set")]),e._v(" "),t("ul",[t("li",[e._v("简单类型")])]),e._v(" "),t("p",[e._v("如果是简单类型则就是把依赖存放在 dep 属性中")])])}),[],!1,null,null,null);t.default=_.exports}}]);