---
title: 基础知识
date: 2020-12-13
---

# 计算机原理

```js
// 计算机原理之计算机发展简史
1. 电子管计算机 // 1946 - 1957 第一台电子管计算机是 埃尼阿克（ENIAC）
    1. 集成度小，空间占用大
    2. 功耗高，运行速度慢
    3. 操作复杂，更换程序需要接线
2. 晶体管计算机 // 1957 - 1964
    1. 集成度相对较高，空间占用相对小
    2. 功耗相对较低，运行速度较快
    3. 操作相对简单，交互更加方便
3. 集成电路计算机 // 1964 - 1980
    1. 计算机变得更小
    2. 功耗变得更低
    3. 计算速度变得更快
4. 超大规模集成电路计算机 // 1980 - 现在
    1. 一个芯片集成了上百万的晶体管
    2. 速度更快，体积更小，价格更低，更能被大众接收
    3. 用途丰富：文本处理、表格处理、高交互的游戏与应用
----------------------------------------------------------------------------------------------
// 计算机原理之计算机的分类
1. 超级计算机
    1. 功能最强、运算速度最快、存储量最大的计算机
    2. 多用于国家高科技领域和尖端技术研究
    3. 标记它们运算速度的单位是 TFLop/s // 1TFLop/s = 每秒一万亿次浮点计算
2. 大型计算机
    1. 又称大型机、大型主机、主机等
    2. 具有高性能，可处理大量数据与复杂的运算
    3. 在大型市场领域， IBM 占据着很大的份额
3. 迷你计算机 // 服务器，机房中的计算机
    1. 也称小型机，普通服务器
    2. 不需要特殊的空调场所
    3. 具备不错的算力，可以完成较复杂的运算
4. 工作站
    1. 高端的通用微型计算机，提供比个人计算机更强大的性能
    2. 类似于普通台式电脑，体积较大，但性能强劲
5. 微型计算机
    1. 又称为个人计算机，是最普通的一类计算机
----------------------------------------------------------------------------------------------
// 计算机原理之计算机的体系和结构
1. 冯诺依曼体系：将程序指令和数据一起存储的计算机设计概念结构
2. 早期的计算机仅含固定用途程序，改变程序就得更改结构，重新设计电路
3. 冯诺依曼体系的概念就是把程序存储起来并设计通用电路，即存储程序指令，设计通用电路
4. 必须有存储器、控制器、运算器、输入设备、输出设备 // 现代计算机都是冯诺依曼机
5. 冯诺依曼机：
    1. 能够把需要的程序和数据送至计算机中 // 输入设备
    2. 能够长期记忆程序、数据、中间结果及最终运算结果的能力 // 存储器
    3. 能够具备算术、逻辑运算和数据传送等数据加工处理的能力 // 控制器和运算器
    4. 能够按照要求将处理结果输出给用户
6. 冯诺依曼瓶颈：cpu = 运算器 + 控制器 // cpu 和存储器速率之间的问题无法调和
7. 现代计算机的结构：
    1. cpu = 运算器 + 控制器 + 存储器
    2. 现代计算机在冯诺依曼体系结构基础上进行修改
    3. 解决 cpu 与存储设备之间的性能差异问题
----------------------------------------------------------------------------------------------
// 计算机原理之计算机的层次与编程语言
1. 人类语言和计算机语言不相同，所以需要进行语言之间的转换
2. 什么是程序翻译？
    1. 使用高级的计算机语言通过编译器变成计算机能够执行的语言即为程序翻译
    2. 翻译过程会生成新的计算机执行程序
    3. C、C++、Golang、Object-C
3. 什么是程序解析？
    1. 使用高级的计算机语言作为输入，用计算机能够执行的程序进行转换（解析器）生成计算机能够执行的逻辑，就是程序解析
    2. 解析过程不生成新的计算机执行程序，而是直接执行
    3. 解析过程是由计算机能够执行的语言编写的解析器去解析计算机高级语言
    4. Python、php、javascript
4. java 和 c# 属于翻译 + 解析
    java 程序先要通过 jvm 虚拟机编译成 jvm 字节码再通过解释器变成机器码执行
5. 计算机的层次：硬件逻辑层 ——> 微程序机器层 ——> 传统机器层 ——> 操作系统层 ——> 汇编语言层 ——> 高级语言层 ——> 应用层
    1. 硬件逻辑层：门、触发器等逻辑电路组成，属于电子工程的领域
    2. 微程序机器层：编程语言是微指令集，微指令所组成的微程序直接交由硬件执行
    3. 传统机器层：
        1. 编程语言是 cpu 指令集（机器指令）
        2. 编程语言和硬件是直接相
        3. 不同架构的 cpu 使用不同的 cpu 指令集
        4. 一条机器指令对应一个微程序
        5. 一个微程序对应一组微指令
   4. 操作系统层：向上提供了简易的操作界面，向下对接了指令系统，管理硬件资源，操作系统层是在软件和硬件之间的适配层
   5. 汇编语言层：
      1. 编程语言是汇编语言
      2. 汇编语言可以翻译成可直接执行的机器语言
      3. 完成翻译的过程的程序就是汇编器
   6. 高级语言层：
      1. 编程语言为广大程序员所接受的高级语言
      2. 高级语言的类别非常多，有几百种，常见的有 Python、java、C、C++、Golang 等
   7. 应用层：满足计算机针对某种用途而专门设计 // word、ppt、xls
----------------------------------------------------------------------------------------------
// 计算机原理之计算机的计算单位
1. 容量单位 // 1024 = 2^10
    1. 在物理层面，高低电平记录信息
    2. 理论上只认识 0 和 1 两种状态 // 0 和 1 称为比特位 bit
    3. 8bit（比特位） = 1Byte（字节）// 常用于门电路
    4. 1024Byte（字节）= 1KB（千字节）// 常用于寄存器
    5. 1024KB（千字节）= 1MB（兆字节）// 常用于高速缓存
    6. 1024MB（兆字节）= 1GB（吉字节）// 常用于内存/硬盘
    7. 1024GB（吉字节）= 1TB（太字节）// 常用于硬盘
    8. 1024TB（太字节）= 1PB（拍字节）// 常用于云硬盘
    9. 1024PB（拍字节）= 1EB（艾字节） // 常用于数据仓库
    10. 1GB 内存可以存储多少字节的数据？可以存储多少比特数据？
        1GB = 1024^3Bytes = 1024^3 * 8bits
    11. 为什么网上买的移动硬盘 500GB，格式化后就只有 465GB？
        硬盘商一般用 10 进位标记容量 // (500 * 1000^3) / 1024^3 = 465
2. 速度单位
    1. 网络速度的 100M 宽度即 100M = 100M/s
    2. 为什么电信拉的 100M 光纤，测试峰值速度只有 12M 每秒？
        1. 网络常用单位为 Mbps // 需要除 8 相当于 bit ——> Byte 的换算，前面多了个 M 而已
        2. 100M/s = 100Mbps = 100Mbit/s = (100 / 8)MB/s = 12.5MB/s
    3. cpu 速度一般体现为 cpu 的时钟频率
    4. cpu 的时钟频率的单位一般是赫兹 // Hz
    5. 主流 cpu 的时钟频率都在 2GHz 以上
    6. Hz 其实就是秒分之一，它是每秒中的周期性变动重复次数的计量 // 人耳能听到的震动频率是 20 - 20000 Hz
    7. 并不是描述计算机领域所专有的单位 // 如蜜蜂翅膀每秒震动 400 次，即 400Hz 
    8. cpu 速度：2GHz = 2 * 1000^3Hz = 每秒 20 亿次
----------------------------------------------------------------------------------------------
// 计算机原理之计算机的字符和编码集
1. 字符编码集的历史：ASCLL 码 ——> Extended ASCLL 码 ——> 字符编码集的国际化
2. ASCLL 码：
    1. 使用 7 个 bits 就可以完全表示 ASCLL 码 // 33 + 95 = 2^7
    2. 包含 95 个可打印字符
    3. 33 个不可打印字符（包括控制字符）
    4. 因为很多应用或者国家中的符合都无法表示所以有了 Extended ASCLL 码
3. Extended ASCLL 码：
    1. 第一次对 ASCLL 码进行扩充，7bit ——> 8bit
    2. 扩充了常见的数学运算符、带音标的欧洲字符、其他常用符、表格符等
4. 字符编码集的国际化：
    1. 欧洲、中亚、东亚、拉丁美洲国家的语言多样性
    2. 语言体系不一样，不以有限字符组合的语言 // 不像英文是都是由 a-z 表示
    3. 中国、韩国、日本等的语言最为复杂
5. 中文编码集：
    1. GB2312 // 不符合国际标准
        1. 《信息交换用汉字编码字符集——基本集》
        2. 一共收录了 7445 个字符
        3. 包括 6763 个汉字和 682 个其他符号
    2. GBK // 对国内有效，如果外国人访问 GBK 的网站且没安装 GBK 则会显示乱码
        1. 《汉字内码扩展规范》
        2. 向下兼容 GB2312，向上支持国际 ISO 标准
        3. 收录了 21003 个汉字，支持全部中日韩汉字
        4. windows 系统默认使用 GBK 编码
    3. Unicode // 兼容全球的字符集
        1. 统一码、万国码、单一码
        2. Unicode 定义了世界通用的符号集，UTF-* 实现了编码 // UTF-8
        3. UTF-8 以字节为单位对 Unicode 进行编码
----------------------------------------------------------------------------------------------
// 计算机原理之计算机的总线
1. 总线的概述：
    1. USB 即 Universal Serial Bus // 通行串行总线
    2. 提供了对外连接的接口
    3. 不同设备可以通过 USB 接口进行连接
    4. 连接的标准，促使外围设备接口的统一
    5. 解决不同设备之间的通信问题
2. 总线的分类：
    1. 片内总线：
        1. 芯片内部的总线
        2. 寄存器与寄存器之间
        3. 寄存器与控制器、运算器之间
        4. 高集成度芯片内部的信息传输线
    2. 系统总线：
        1. cpu、主内存、IO 设备、各组件之间的信息传输线
        2. 数据总线：
            1. 双向传输各个部件的数据信息
            2. 数据总线的位数（总线宽度）是数据总线的重要参数
            3. 一般与 cpu 位数相同（32位、64位）
        3. 地址总线：
            1. 指定源数据或目的数据在内存中的地址
            2. 地址总线的位数与存储单元有关
            3. 地址总线位数 = n，寻找范围：0 - 2^n
        4. 控制总线:
            1. 控制总线是用来发出各种控制信号的传输线
            2. 控制信号经由控制总线从一个组件发给另外一个组件
            3. 控制总线可以监视不同组件之间的状态（就绪/未就绪）
3. 总线的仲裁：解决不同设备使用总线的优先顺序的设备 // 为了解决总线使用权的冲突问题
4. 总线的仲裁方法：
    1. 链式查询：// 顺序调用
        1. 好处：电路复杂度低，仲裁方式简单
        2. 坏处：优先级低的设备难以获得总线的使用权
        3. 坏处：对电路故障敏感
    2. 计时器定时查询：
        1. 仲裁控制器对设备编号并使用计数器累计计数
        2. 接收到仲裁信号后，往所有设备发出计数值
        3. 计数值与设备编号一致则获得总线使用权
    3. 独立请求：
        1. 每个设备均有总线独立连接仲裁器
        2. 设备可单独向仲裁器发送请求和接收请求
        3. 当同时收到多个请求信号，仲裁器有权按优先级分配使用权
        4. 好处：响应速度快，优先顺序可动态改变
        5. 坏处：设备连线多，总线控制复杂
----------------------------------------------------------------------------------------------
// 计算机原理之计算机的输入输出设备
1. 常见的输入设备：
    1. 字符输入设备：
        1. 键盘 // 薄膜键盘、机械键盘、电容键盘
    2. 图像输入设备：
        1. 鼠标
        2. 数位板
        3. 扫描仪
2. 常见的输出设备：
    1. 显示器
    2. 打印机
    3. 投影仪
3. 输入输出接口的通用设计：
    1. 数据线：
        1. 是 IO 设备与主机之间进行数据交换的传送线
        2. 单向传输数据线
        3. 双向传输数据线
    2. 状态线：
        1. IO 设备状态向主机报告的信号线
        2. 查询设备是否已经正常连接并就绪
        3. 查询设备是否已经被占用
    3. 命令线：
        1. cpu 向设备发送命令的信号线
        2. 发送读写信号
        3. 发送启动停止信号
    4. 设备选择线：
        1. 主机选择 IO 设备进行操作的信号线
        2. 对连接在总线上的设备进行选择
4. cpu 与 io 设备的通信：// CPU 速度与 IO 设备速度不一致
    1. 程序中断：
        1. 当外围 IO 设备就绪时，向 cpu 发出中断信号
        2. cpu 有专门的电路响应中断信号
        3. 提供低速设备通知 cpu 的一种异步的方式
        4. cpu 可以高速运转同时兼顾低速设备的响应
    2. DMA （直接存储器访问）
        1. DMA 直接连接主存与 IO 设备
        2. DMA 工作时不需要 cpu 的参与
        3. 当主存与 IO 设备交换信息时，不需要中断 cpu，可以提高 cpu 的效率
        4. 硬盘、外置显卡
----------------------------------------------------------------------------------------------
// 计算机原理之计算机的存储器
1. 存储器的分类：
    1. 按存储介质分类：
        1. 半导体存储器 // 内存、U盘、固态硬盘
        2. 磁存储器 // 磁带、磁盘
    2. 按存取方式分类：
        1. 随机存储器（RAM）// 随机读取、与位置无关
        2. 串行存储器 // 与位置有关、按顺序查找
        3. 只读存储器（ROM）// 只读不写
2. 存储器的层次结构：
    1. 读写速度
    2. 存储容量
    3. 价格
    4. 容量 + 价格 => 位价 // 每比特位价格
    5. 缓存 // cpu 的寄存器和高速缓存，速度最快，价格高
    6. 主存 // 计算机的内存，速度中，价格中
    7. 辅存 // 磁盘、u盘、移动硬盘，速度慢，价格低
    8. cpu <——> 高速缓存 <——> 主存：
        1. 缓存——主存层次
        2. 原理：局部性原理
        3. 实现：在 cpu 和主存之间增加一层速度快（容量小）的 cache
        4. 目的：解决主存速度不足的问题
    9. 主存 <——> 辅存
        1. 主存——辅存层次
        2. 原理：局部性原理
        3. 实现：主存之外增加辅助存储器（磁盘、SD卡、U盘等）
        4. 目的：解决主存容量不足的问题
----------------------------------------------------------------------------------------------
// 计算机原理之计算机的主存储器和辅助存储器
1. 主存储器——内存：
    1. RAM（随机存取存储器：Random Access Memory）
    2. RAM 通过电容存储数据，必须隔一段时间刷新一次
    3. 如果断电，那么一段时间后将丢失所有数据
    4. 32位系统对应的内存大小：2^32 = 4 * 2^30 = 4GB
    5. 64位系统对应的内存大小：2^64 = 2^34 * 2^30 = 2^34GB
2. 辅助存储器——磁盘：
    1. 表面是可磁化的硬磁特性材料
    2. 移动磁头径向运动读取磁道信息
    3. 算法：
        1. 先来先服务算法：
            1. 按顺序访问进程的磁道读写需求
        2. 最短寻道时间优先：
            1. 与磁头当前位置有关
            2. 优先访问离磁头最近的磁道
        3. 扫描算法（电梯算法）：
            1. 每次只往一个方向移动
            2. 到达一个方向需要服务的尽头再反方向移动
        4. 循环扫描算法：
            1. 读取时只往一个方向读取
----------------------------------------------------------------------------------------------
// 计算机原理之计算机的高速缓存
1. 工作原理：
    1. 字：是指存放在一个存储单元中的二进制代码组合
    2. 字块：存储在连续的存储单元中而被看做是一个单元的一组字
    3. 高速缓存来自于主存，存储逻辑结构类似，缓存的容量较小，缓存的速度更快
    4. 如果 cpu 需要的数据在缓存里就直接拿，如果不在，缓存则会去主存中拿
    5. 命中率是衡量缓存的重要性能指标
    6. 理论上 cpu 每次都能从高速缓存取数据的时候，命中率为 1
2. 替换策略
    1. 随机算法
    2. 先进先出算法（FIFO）
    3. 最不经常使用算法（LFU）
    4. 最近最少使用算法（LRU）
----------------------------------------------------------------------------------------------
// 计算机原理之计算机的指令系统
1. 机器指令的形式：
    1. 操作码：
        1. 操作码指明指令所要完成的操作
        2. 操作码的位数反映了机器的操作种类
    2. 地址码：
        1. 地址码直接给出操作数或者操作数的地址
        2. 分三地址指令、二地址指令、一地址指令、零地址码指令（在机器指令中无地址码，空操作、停机操作、中断返回操作等）
2. 机器指令的操作类型：
    1. 数据传输：
        1. 寄存器之间、寄存器与存储单元、存储单元之间
        2. 数据读写、交换地址数据、清零置一等操作
    2. 算术逻辑操作：
        1. 操作数之间的加减乘除运算
        2. 操作数的与或非等逻辑位运算
    3. 移位操作：
        1. 数据左移（乘2），数据右移（除2）
        2. 完成数据在算术逻辑单元的必要操作
    4. 控制指令：
        1. 等待指令、停机指令、空操作指令、中断指令等
3. 机器指令的寻址方式：
    1. 指令寻址：
        1. 顺序寻址
        2. 跳跃寻址
    2. 数据寻址：
        1. 立即寻址：// 优点：速度快 缺点：地址码位数限制操作数表示范围
            1. 指令直接获得操作数
            2. 无需访问存储器
        2. 直接寻址：// 优点：寻找操作数简单 缺点：地址码位数限制操作数寻址范围
            1. 直接给出操作数在主存的地址
            2. 寻找操作数简单，无需计算数据地址
        3. 间接寻址：// 优点：操作数寻址范围大 缺点：速度慢
            1. 指令地址码给出的是操作数地址的地址
            2. 需要访问一次或多次主存来获取操作数
----------------------------------------------------------------------------------------------
// 计算机原理之计算机的控制器
1. 控制器是协调和控制计算机运行的
2. 控制器：
    1. 程序计数器：
        1. 程序计数器用来存储下一条指令的地址
        2. 循环从程序计数器中拿出指令
        3. 当指令被拿出时，指向下一条指令
    2. 时序发生器：
        1. 电气工程领域，用于发送时序脉冲
        2. cpu 依据不同的时序脉冲有节奏的进行工作
    3. 指令译码器：
        1. 指令译码器是控制器的主要部件之一
        2. 计算机指令由操作码和地址码组成
        3. 翻译操作码对应的操作以及控制传输地址码对应的数据
    4. 各种寄存器
        1. 指令寄存器：
            1. 指令寄存器也是控制器的主要部件之一
            2. 从主存或高速缓存取计算机指令
        2. 主存地址寄存器：
            1. 保存当前 cpu 正要访问的内存单元的地址
        3. 主存数据寄存器：
            1. 保存当前 cpu 正要读或写的主存数据
        4. 通用寄存器：
            1. 用于暂时存放或传送数据或指令
            2. 可保存 ALU 的运算中间结果
            3. 容量比一般专用寄存器要大
    5. 总线
----------------------------------------------------------------------------------------------
// 计算机原理之计算机的运算器
1. 运算器是用来进行数据运算加工的
2. 运算器：
    1. 数据缓冲器：
        1. 分为输入缓冲和输出缓冲
        2. 出入缓冲暂时存放外设送过来的数据
        3. 输出缓冲暂时存放往外设的数据
    2. ALU：
        1. 算术逻辑单元，是运算器的主要组成
        2. 常见的位运算（左右移、与或非等）
        3. 算术运算（加减乘除等）
    3. 通用寄存器：
        1. 用于暂时存放或传送数据或指令
        2. 可保存 ALU 的运算中间结果
        3. 容量比一般专用寄存器要大
    4. 状态字寄存器：
        1. 存放运算状态（条件码、进位、溢出、结果正负等）
        2. 存放运算控制信息（调试跟踪标记位、允许中断位等）
    5. 总线
----------------------------------------------------------------------------------------------
// 计算机原理之计算机指令的执行过程
1. 指令执行过程：
    1. 取指令：
        1. 从缓存取指令
        2. 送到指令寄存器
    2. 分析指令：
        1. 指令译码器译码
        2. 发出控制信号
        3. 程序计数器 +1
    3. 执行指令：
        1. 装载数据到寄存器
        2. ALU 处理数据
        3. 记录运算状态
        4. 送出运算结果
2. cpu 的流水线设计：
    1. 类似工厂的装配线
    2. 工厂的装配线使得多个产品可以同时被加工
    3. 在同一个时刻，不同产品均位于不同的加工阶段
----------------------------------------------------------------------------------------------
// 计算机原理之进制运算基础
1. 进制概述：
    1. 进位制是一种计数方式，也称进位计数法或位值计数法
    2. 有限种数字符合来表示无限的数值
    3. 使用的数字符号的数目称为这种进位制的基数或底数
    4. 十进制
    5. 八进制
    6. 十六进制：
        1. [0-9] 和 A、B、C、D、E、F
    7. 二十进制：
        1. 玛雅文明的玛雅数字
        2. 因努伊特的因努伊特数字
    8. 六十进制：
        1. 时间、坐标、角度等量化数据
    9. 计算机喜欢二进制，但是二进制表达太长了
    10. 使用大进制位可以解决这个问题
    11. 八进制、十六进制满足2的n次方的要求
    12. 示例：1024
        1. 二进制表示：0b1000000000
        2. 八进制表示：0o2000
        3. 十六进制表示：0x400
2. 二进制运算的基础：
    1. 二进制转十进制：乘 2 的幂次方相加
        1. 二进制：01100101 ——> 1 * 2^6 + 1 * 2^5 + 1 * 2^2 + 1 = 101
    2. 小数二进制转十进制：乘 2 的负幂次方相加
        1. 二进制：0.11001 ——> 1 * 2^-1 + 1 * 2^-2 + 1 * 2^-5 = 0.78125 = 25/32
    3. 十进制转二进制：除 2 取余，往上数 // 除到商 = 0
    4. 小数十进制转二进制：乘 2 取积，省下的继续乘 2 直到分母为 0 ，往下数
----------------------------------------------------------------------------------------------
// 计算机原理之二进制的原码表示法
1. 在日常生活中用加号表示正数，减号表示负数
2. 在计算机中使用 0 表示正数，使用 1 表示负数
3. 如：+237 = 011101101 // 11101101 是 237 的二进制表示法，最前面的 0 表示正数
4. 如：-237 = 111101101 // 11101101 是 237 的二进制表示法，最前面的 1 表示负数
5. 原码表示法：
    1. 使用 0 表示正数，1 表示负数
    2. 规定符号位位于数值第一位
    3. 表达简单明了，是人类最容易理解的表示法
    4. 0 有两种表示方法：00 和 10 ，一个是正零，一个是负零，虽然都是零
    5. 原码进行运算非常复杂，特别是两个操作数符号不同的时候：
        1. 需要判断两个操作数绝对值大小
        2. 使用绝对值大的数减去绝对值小的数
        3. 对于符号值，以绝对值大的为准
    6. 因为很复杂所以有二进制的补码表示法
----------------------------------------------------------------------------------------------
// 计算机原理之二进制的补码表示法
1. 二进制正数的补码 = x > 0 ? x : 2^(n+1) + x // 如果 x 大于 0 补码则是原码，如果 x 小于 0 补码则是 2 的 n + 1 次方再加 x
2. 二进制小数的补码 = x > 0 ? x : 2 + x // 如果 x 大于 0 补码则是原码，如果 x 小于 0 补码则是 2 加 x
3. 示例：
    1. n = 4，x = 13，计算 x 的二进制原码和补码？
        原码：x = 01101 // 第一个 0 表示正数
        补码：x = 01101 // x 大于 0 补码 === 补码
    2. n = 4，x = -13，计算 x 的二进制原码和补码？
        原码：x = 11101 // 第一个 1 表示负数
        补码：x = 2^(4+1) - 13 = 100000 - 1101 = 10011 // 因为符号位 n 是 4，所以符号位在从右往左数第 4 位，即第一位 1 是表示符号位
4. 引进补码的目的：// 求反码再求补码
    1. 减法运算复杂，希望找到使用正数替代负数的方法
    2. 使用加法代替减法操作，从而消除减法
    3. 在计算补码的过程中，还是使用了减法
    4. 为了消除在计算补码过程中使用减法的操作引进了二进制反码表示法
----------------------------------------------------------------------------------------------
// 计算机原理之二进制的反码表示法
1. 反码的目的是找出原码和补码之间的规律，消除转换过程中的减法
2. 二进制的补码 = x > 0 ? x : (2^(n+1) - 1) + x // 如果 x 大于 0 补码则是原码，如果 x 小于 0 补码则是 2 的 n + 1 次方减 1 再加 x
3. 示例：
    1. n = 4，x = -13，计算 x 的二进制原码和补码？
        原码：x = 11101 // 第一个 1 表示负数
        补码：x = (2^(4+1) - 1) - 13 = 011111 - 1101 = 10010 // 因为符号位 n 是 4，所以符号位在从右往左数第 4 位，即第一位 1 是表示符号位
    2. -13 的原码、补码、反码比较：
        原码：11101
        补码：10011
        反码：10010
    3. -7 的原码、补码、反码比较：
        原码：10111
        补码：11001
        反码：11000
4. 通过 3.2 和 3.3 示例可得出规律：
    1. 负数的反码等于原码除符号位外按位取反
    2. 负数的补码等于反码 + 1
----------------------------------------------------------------------------------------------
// 计算机原理之定点数和浮点数
1. 定点数的表示方法：
    1. 小数点固定在某个位置的数称之为定点数
    2. 把小数点放在符号位和数值位之间表示纯小数
    3. 把小数点放在数值位之后表示纯整数
    4. 如果即不是纯小数也不是纯整数需要乘以比例因子以满足定点数保存格式
2. 浮点数的表示方法：
    1. 计算机处理的很大程度上不是纯小数或纯整数
    2. 数据范围很大，定点数难以表达
    3. 浮点数的表示格式：// 尾数规定必须是纯小数
        N = S * r^j
        浮点数 = 尾数 * 基数^阶码
        11.0101 = 0.110101 * 2^10
        11.0101 = 0.0110101 * 2^11
    4. 浮点数的表示范围：
        单精度浮点数：使用 4 字节、32 位来表示浮点数 // float
        双精度浮点数：使用 8 字节、64 位来表示浮点数 // double
    5. 浮点数的规格化:
        1. 尾数规定使用纯小数
        2. 尾数最高位必须是 1
3. 定点数与浮点数的对比：
    1. 当定点数与浮点数位数相同时，浮点数表示的范围更大
    2. 当浮点数尾数为规格化数时，浮点数的精度更高
    3. 浮点数运算包含阶码和尾数，浮点数的运算更为复杂
    4. 浮点数在数的表示范围、精度、溢出处理、编程等方面均优于定点数
    5. 浮点数在数的运算规则、运算速度、硬件成本方面不如定点数
----------------------------------------------------------------------------------------------
// 计算机原理之定点数的加减法运算
1. 整数加法：A[补] + B[补] = [A + B][补](mod2^n+1)
2. 小数加法：A[补] + B[补] = [A + B][补](mod2)
3. 数值位与符号位一同运算，并将符号位产生的进位自然丢掉
4. 溢出判断：
    1. 单符号位表示变成双符号位：0 ——> 00，1 ——> 11
    2. 双符号位产生的进位丢弃
    3. 结果的双符号位不同则表示溢出
5. 整数减法：A[补] - B[补] = A + (-B)[补](mod2^n+1)
6. 小数减法：A[补] - B[补] = A + (-B)[补](mod2)
7. -B[补]等于B[补]连同符号位按位取反，末位加一
----------------------------------------------------------------------------------------------
// 计算机原理之浮点数的加减法运算
1. 对阶
2. 尾数求和
3. 尾数规格化
4. 舍入
5. 溢出判断
----------------------------------------------------------------------------------------------
// 计算机原理之浮点数的乘除法运算
1. 乘法：阶码相加，尾数求积
2. 除法：阶码相减，尾数求商
```

# 操作系统

```js
// 操作系统概览
1. 什么是操作系统，为什么需要操作系统？
    1. 操作系统的种类是多种多样的，不局限于计算机
    2. 从手机到超级计算机，操作系统可简单也可复杂 // Android、IOS、Windows、Linux、MavOS
    3. 在不同的设备上，操作系统可向用户呈现多种操作手段
    4. 我们不可能直接操作计算机硬件
    5. 设备种类繁多复杂，需要统一界面
    6. 操作系统的简易型使得更多人能够使用计算机
2. 操作系统的基本功能
    1. 操作系统统一管理计算机资源
        1. 处理器资源
        2. 存储器资源
        3. IO设备资源
        4. 文件资源
    2. 操作系统实现了对计算机资源的抽象
        1. 用户无需面向硬件接口编程
        2. IO 设备管理软件，提供读写接口
        3. 文件管理软件，提供操作文件接口
    3. 操作系统提供了用户与计算机之间的接口
        1. 图像窗口形式 // windows
        2. 命令形式 // shell、linux
        3. 系统调用形式 // 操作系统方法
3. 操作系统相关概念
    1. 并发性
        1. 并行是指两个或多个事件可以 在同一时刻发生
        2. 并发是指两个或多个事件可以在同一个时间间隔发生
    2. 共享性
        1. 共享性表现为操作系统中的资源可以供多个并发的程序共同使用
        2. 这种共同使用的形式称之为资源共享
        3. 互斥共享形式
            1. 当资源被程序A占用时，其他想使用的话只能等待
            2. 只有进程A使用完以后，其他进程才可以使用该资源
        4. 同时访问形式
            1. 某种资源在一段时间内并发的被多个程序访问
            2. 这种同时是宏观的，从宏观去看该资源可以被同时访问
    3. 虚拟性
        1. 虚拟性表现为把一个物理实体转变为若干个逻辑实体
        2. 物理实体是真实存在的，逻辑实体是虚拟的
        3. 时分复用技术
            1. 资源在时间上进行复用，不同程序并发使用
            2. 多道程序分时使用计算机的硬件资源
            3. 提高资源的利用率
            4. 虚拟处理器技术
                1. 借助多道程序设计技术
                2. 为每个程序建立进程
                3. 多个程序分时复用处理器
            5. 虚拟设备技术
                1. 物理设备虚拟为多个逻辑设备
                2. 每个程序占用一个逻辑设备
                3. 多个程序通过逻辑设备并发访问
        4. 空分复用技术
            1. 虚拟磁盘技术
                1. 物理磁盘虚拟为逻辑磁盘
                2. C、D、E等逻辑盘
                3. 使用起来更加安全、方便
            2. 虚拟内存技术
                1. 在逻辑上扩大程序的存储容量
                2. 使用比实际内存更大的容量
                3. 大大提升编程效率
    4. 异步性
        1. 在多道程序环境下，允许多个进程并发执行
        2. 进程在使用资源时可能需要等待或放弃
        3. 进程的执行并不是一气呵成的，而是以走走停停的形式推进
----------------------------------------------------------------------------------------------
// 进程管理之进程实体
1. 为什么需要进程
    1. 没有操作系统之前，资源属于当前运行的程序 // 一次只能运行一个程序
    2. 有了操作系统之后，引入了多道程序设计的概念
    3. 合理的隔离资源、运行环境、提升资源利用率
    4. 进程是系统进行资源分配和调度的基本单位
    5. 进程作为程序独立运行的载体保障程序正常执行
    6. 进程的存在使得操作系统资源的利用率大幅提升
2. 进程的实体
    1. 主存中的进程形态 // 进程标识符、处理机状态、进程调度信息、进程控制信息
        1. 标识符：唯一标记一个进程，用于区别其他进程 // id
        2. 状态：标记进程的进程状态 // 运行态
        3. 程序计数器：进程即将被执行的下一条指令的地址
        4. 内存指针：程序代码、进程数据相关指针
        5. 上下文数据：进程执行时处理器存储的数据
        6. IO 状态信息：被进程 IO 操作所占用的文件列表
        7. 记账信息：使用处理器时间、时钟数总和等
        8. 进程控制块（PCB）
            1. 用于描述和控制进程运行的通用数据结构
            2. 记录进程当前状态和控制进程运行的全部信息
            3. PCB 的使得进程是能够独立运行的基本单位
            4. PCB 是操作系统进行调度经常会被读取的信息
            5. PCB 是常驻内存的，存放在系统专门开辟的 PCB 区域内
    2. 进程与线程
        1. 一个进程可以有一个或多个线程
        2. 线程是操作系统进行运行调度的最小单位
        3. 包含在进程之中，是进程中实际运行工作的单位
        4. 一个进程可以并发多个线程，每个线程执行不同的任务
        5. 进程的线程共享进程资源
        6. 进程和线程对比：
            1. 资源：
                1. 进程是资源分配的基本单位
                2. 线程不拥有资源
            2. 调度：
                1. 进程是独立调度的基本单位
                2. 线程是独立调度的最小单位
            3. 系统开销：
                1. 进程系统开销大
                2. 线程系统开销小
            4. 通信：
                1. 进程 IPC
                2. 线程读写同一进程数据通信
----------------------------------------------------------------------------------------------
// 进程管理之五状态模型
1. 就绪
    1. 当进程分配到除 cpu 以外所有必要的资源后
    2. 只要再获得 cpu 的使用权，就可以立即运行
    3. 其他资源都准备好，只差 cpu 资源的状态为就绪状态
    4. 在一个系统中多个处于就绪状态的进程通常排成一个队列
2. 执行
    1. 进获得 cpu，其程序正在执行称为执行状态
    2. 在单处理机中，在某个时刻只能有一个进程是处于执行状态
3. 阻塞
    1. 进程因某种原因如：其他设备未就绪而无法继续执行
    2. 从而放弃 cpu 的状态称为阻塞状态
    3. 阻塞队列
4. 创建
    1. 分配PCB——>插入就绪队列
    2. 创建进程时拥有 PCB 但其他资源尚未就绪的状态称为创建状态
5. 终止
    1. 系统请求——>PCB归还
    2. 进程结束由系统清理或者归还 PCB 的状态称为终止状态
6. 创建——>就绪 // 创建完成
7. 就绪——>执行 // 进程调度
8. 执行——>就绪 // 时间片用完
9. 执行——>阻塞 // IO 请求
10. 阻塞——>就绪 // IO 完成
11. 执行——>终止 // 执行完成
----------------------------------------------------------------------------------------------
// 进程管理之进程同步
1. 为什么需要进程间同步 // 彼此相互之间没有通信
    1. 对竞争资源在多进程间进行使用次序的协调
    2. 使得并发执行的多个进程之间可以有效使用资源和相互合作
2. 进程间同步的原则
    1. 空闲让进：资源无占用，允许使用
    2. 忙则等待：资源有占用，请求进程等待
    3. 有限等待：保证有限等待时间能够使用资源
    4. 让权等待：等待时，进程需要让出 cpu
3. 进程同步的方法：
    1. 消息队列
    2. 共享存储
    3. 信号量
4. 线程同步的方法：
    1. 互斥量
    2. 读写锁
    3. 自旋锁
    4. 条件变量
----------------------------------------------------------------------------------------------
// Linux 的进程管理
1. Linux 进程的相关概念
    1. 进程的类型：
        1. 前台进程：
            1. 终端 Shell
            2. 前台进程就是具有终端，可以和用户交互的进程
        2. 后台进程：
            1. 与前台进程相对，么有占用终端的就是后台进程
            2. 后台程序基本上不和用户交互，优先级比前台进程低
            3. 将需要执行的命令以 '&' 符号结束
        3. 守护进程：
            1. 守护进程是特殊的后台进程
            2. 很多守护进程在系统引导的时候启动，一直运行直到系统关闭
            3. Linux 有很多典型的守护进程
            4. 进程名字以 'd' 结尾的一般都是守护进程：
                1. crond
                2. httpd
                3. sshd
                4. mysqld
    2. 进程的标记:
        1. 进程 ID：
            1. 进程 ID 是进程的唯一标记，每个进程拥有不同的 ID
            2. 进程 ID 表现为一个非负整数，最大值由操作系统限定
            3. 操作系统提供 fork 函数接口创建进程
            4. 父子进程关系可以通过 pstree 命令查看
            5. ID 为 0 的进程为 idle 进程，是系统创建的第一个进程
            6. ID 为 1 的进程为 init 进程，是 0 号进程的子进程，完成系统初始化
            7. init 进程是所有用户进程的祖先进程
        2. 进程的状态标记：
            1. 状态符号 'R' 代表进程正处于运行状态 // TASK_RUNNING
            2. 状态符号 'S' 代表进程正处于睡眠状态 // TASK_INTERRUPTIBLE
            3. 状态符号 'D' 代表进程正处于 IO 等待的睡眠状态 // TASK_UNINNTERRUPTIBLE
            4. 状态符号 'T' 代表进程正处于暂停状态 // TASK_STOPPED
            5. 状态符号 'Z' 代表进程正处于退出状态，或僵尸进程 // TASK_DEAD or EXIT_ZOMBIE
2. 操作 Linux 进程的相关命令
    1. ps 命令 // 查看进程列表
    2. top 命令 // 查看进程状态
    3. kill 命令 // 给进程发生信息
----------------------------------------------------------------------------------------------
// 作业管理之进程调度
1. 进程调度概述
    1. 进程调度是指计算机通过决策决定哪个就绪进程可以获得 cpu 使用权 // 多道程序设计
    2. 保留旧进程的运行信息，请出旧进程 // 收拾包袱
    3. 选择新进程，准备运行环境并分配 cpu // 新进驻
    4. 就绪队列的排队机制
        1. 将就绪进程按照一定的方式排成队列，以便调度程序可以最快找到就绪进程
    5. 选择运行进程的委派机制
        1. 调度程序以一定的策略选择就绪进程，将 cpu 资源分配给它
    6. 新老进程的上下文切换机制
        1. 保存当前进程的上下文信息，装入被委派执行进程的运行上下文
    7. 非抢占式调度
        1. 处理器一旦分配给某个进程，就让该进程一直使用下去
        2. 调度程序不以任何原因抢占正在被使用的处理器
        3. 直到进程完成工作或因为 IO 阻塞才会让出处理器
    8. 抢占式调度
        1. 允许调度程序已一定策略暂停当前运行的进程
        2. 保存好旧进程的上下文信息，分配处理器给新进程
    9. 非抢占式调度和抢占式调度的对比
        1. 抢占式调度的系统开销大，非抢占式开销小 // 因为需要切换
        2. 抢占式调度相对公平，非抢占式不公平
        3. 抢占式调度应用于通用系统，非抢占式调度应用于专用系统
2. 进程调度算法
    1. 先来先服务调度算法
    2. 短进程优先调度算法
        1. 调度程序优先选择就绪队列中估计运行时间最短的进程
        2. 短进程优先调度算法不利于长作业进程的执行
    3. 高优先权优先调度算法
        1. 进程附带优先权，调度程序优先选择权重高的进程
        2. 高优先权优先调度算法使得紧迫的任务可以优先处理
    4. 时间片轮转调度算法
        1. 按先来先服务的原则排列就绪进程
        2. 每次从队列头部取出待执行进程，分配一个时间片执行
        3. 是相对公平的调度算法，但不能保证及时响应用户
----------------------------------------------------------------------------------------------
// 作业管理之死锁
1. 死锁的产生
    1. 竞争资源
        1. 共享资源数量不满足各个进程需求
        2. 各个进程之间发生资源进程导致死锁
    2. 进程调度顺序不当
    3. 死锁的必要条件
        1. 互斥条件
            1. 进程对资源的使用时非他性的使用
            2. 某资源只能由一个进程使用，其他进程需要使用只能等待
        2. 请求保持条件
            1. 进程至少保持一个资源，又提出新的资源请求
            2. 新资源被占用，请求被阻塞
            3. 被阻塞的进程不释放自己保持的资源
        3. 不可剥夺条件
            1. 进程获得的资源在未完成使用前不能被剥夺
            2. 获得的资源只能由进程自身释放
        4. 环路等待条件
            1. 发生死锁时，必然存在进程-资源环形链
2. 死锁的处理
    1. 预防死锁的方法
        1. 摒弃请求保持条件
            1. 系统规定进程运行之前，一次性申请所有需要的资源
            2. 进程在运行期间不会提出资源请求，从而摒弃请求保持条件
        2. 摒弃不可剥夺条件
            1. 当一个进程请求新的资源得不到满足时，必须释放占有的资源
        3. 摒弃环路等待条件
            1. 可用资源线性排序，申请必须按照需要递增申请
            2. 线性申请不再形成环路，从而摒弃了环路等待条件
    2. 银行家算法
        1. 客户申请的贷款是有限的，每次申请需声明最大资金量
        2. 银行家在能够满足贷款时，都应该给用户贷款
        3. 客户在使用贷款后，能够及时归还贷款
----------------------------------------------------------------------------------------------
// 存储管理之内存分配与回收
1. 早期计算机编程并不需要过多的存储管理
2. 随着计算机和程序越来越复杂，存储管理成为必要
3. 确保计算机有足够的内存处理数据
4. 确保程序可以从可用内存中获取一部分内存使用
5. 确保程序可以归还使用后的内存以供其他程序使用
6. 内存分配的过程
    1. 单一连续分配
        1. 单一连续分配是最简单的内存分配方式
        2. 只能在单用户、单进程的操作系统中使用
    2. 固定分区分配
        1. 固定分区分配是支持多道程序的最简单存储分配方式
        2. 内存空间被划分为若干固定大小的区域
        3. 每个分区只提供给一个程序使用，互不干扰
    3. 动态分区分配
        1. 根据进程实际需要，动态分配内存空行
        2. 相关数据结构
            1. 动态分区空闲表数据结构
            2. 动态分区空闲链数据结构
        3. 相关分配算法
            1. 首次适应算法 // FF 算法
            2. 最佳适应算法 // BF 算法
            3. 快速适应算法 // QF 算法
7. 内存回收的过程
----------------------------------------------------------------------------------------------
// 存储管理之段页式存储管理
1. 页式存储管理
    1. 将进程逻辑空间等分成若干大小的页面
    2. 相应的把物理内存空间分成与页面大小的物理块 // 字块是相对物理设备的定义
    3. 以页面为单位把进程空间装进物理内存中分散的物理块 // 页面则是相对逻辑空间的定义
2. 段式存储管理
    1. 将进程逻辑空间划分成若干段 // 非等分
    2. 段的长度由连续逻辑的长度决定
    3. 主函数 main、子程序段 x、子函数 y 等
3. 页式存储管理和段式存储管理的对比
    1. 段式存储和页式存储都离散的管理了进程的逻辑空间
    2. 页是物理单位，段式逻辑单位
    3. 分页是为了合理利用空间，分段是满足用户要求
    4. 页大小由硬件固定，段长度可动态变化
    5. 页表信息是一维的，段表信息是二维的
3. 段页式存储管理
    1. 分页可以有效提高内存利用率 // 虽然说存在页内碎片
    2. 分段可以更好满足用户需求
    3. 两者结合，形成段页式存储管理
    4. 先将逻辑空间按段式管理分成若干段
    5. 再把段内空间按页式管理等分成若干页
----------------------------------------------------------------------------------------------
// 存储管理之虚拟内存
1. 虚拟内存概述
    1. 有些进程实际需要的内存很大，超过物理内存的容量
    2. 多道程序设计，使得每个进程可用物理内存更加稀缺
    3. 不可能无限增加物理内存，物理内存总有不够的时候
    4. 虚拟内存是操作系统内存管理的关键技术
    5. 使得多道程序运行和大程序运行称为现实
    6. 把程序使用内存划分，将部分暂时不使用的内存放置在辅存
2. 程序的局部性原理
    1. 局部性原理是指 cpu 访问存储器时，无论是存取指令还是存取数据，所访问的存储单元都趋于聚集在一个较小的连续区域中
    2. 程序运行时，无需全部装入内存，装在部分即可
    3. 如果访问页不在内存，则发出缺页中断，发起页面置换
    4. 从用户层面看，程序拥有很大的空间，即使虚拟内存
    5. 虚拟内存实际是对物理内存的补充，速度接近于内存，成本接近于辅存
3. 虚拟内存的置换算法
    1. 先进先出算法 // FIFO
    2. 最不经常使用算法 // LFU
    3. 最近最少使用算法 // LRU
----------------------------------------------------------------------------------------------
// Linux 的存储管理
1. Buddy 内存管理算法
    1. Buddy 算法是经典的内存管理算法
    2. 算法基于计算机处理二进制的优势具有极高的效率
    3. 算法主要是为了解决内存外碎片的问题
2. Linux 交换空间 // swap 空间
    1. 冷启动内存依赖
    2. 系统睡眠依赖
    3. 大进程空间依赖
3. swap 空间和虚拟内存对比
    1. 都是存在于磁盘
    2. 都是与主存发生置换
    3. swap 空间是操作系统概念，虚拟内存是进程概念
    4. swap 空间解决系统物理内存不足的问题，虚拟内存解决进程物理内存不足的问题
----------------------------------------------------------------------------------------------
// 操作系统的文件管理
1. 文件的逻辑结构
    1. 逻辑结构的文件类型
        1. 有结构文件
            1. 文本文件
            2. 文档
            3. 媒体文件
            4. 文件内存由定长记录和可变长记录组成
            5. 定长记录存储文件格式、文件描述等结构化数据项
            6. 可变长记录存储文件具体内容
        2. 无结构文件
            1. 二进制文件
            2. 链接库
            3. 也称流式文件
                1. exe 文件
                2. dll 文件
                3. so 文件
            4. 文件内容长度以字节为单位
    2. 顺序文件
        1. 顺序文件是指按顺序存放在存储介质中的文件
        2. 磁带的存储特性使得磁带文件只能存储顺序文件
        3. 顺序文件是所有逻辑文件当中存储效率最高的
    3. 索引文件
        1. 可变长文件不适合使用顺序文件格式存储
        2. 索引文件是为了解决可变长文件存储而发明的一种文件格式
        3. 索引文件需要配合索引表完成存储的操作
2. 辅存的存储空间分配
    1. 辅存的分配方式
        1. 连续分配
            1. 顺序读取文件内容非常容易，速度很快
            2. 对存储要求高，要求满足容量的连续存储空间
        2. 链接分配
            1. 隐式链接
            2. 显示链接
            3. 链接分配可以将文件存储在离散的盘块中
            4. 需要额外的存储空间存储文件的盘块链接顺序
        3. 索引分配
            1. 把文件的所有盘块集中存储（索引）
            2. 读取某个文件时，将文件索引读取进内存即可
            3. 每个文件拥有一个索引块，记录所有盘块信息
            4. 索引分配方式支持直接访问盘块
            5. 文件较大时，索引分配方式具有明显优势
    2. 存储空间管理
        1. 空闲表
            1. 空闲盘区的分配与内存分配类似
            2. 首次适应算法、循环适应算法等
            3. 回收过程也与内存回收类似
        2. 空闲链表
            1. 空闲链表法把所有空闲盘区组成一个空闲链表
            2. 每个链表节点存储空闲盘块和空闲的数目
        3. 位示图
            1. 位示图维护成本很低
            2. 位示图可以非常容易找到空闲盘块
            3. 位示图使用 0/1 比特位，占用空间很小
3. 目录管理
    1. 目录树
        1. 任何文件或目录都只有唯一路径
----------------------------------------------------------------------------------------------
// Linux 文件基本操作
1. Linux 目录 // Linux 一切皆是文件
    1. /bin 存放二进制可执行文件，常用命令一般都在这里
    2. /etc 存放系统管理和配置文件
    3. /home 存放所有用户文件的根目录，是用户主目录的基点，比如用户 user 的主目录就是 /home/user
    4. /usr 用于存放系统应用程序，比较重要的目录 /usr/local 本地系统管理员软件安装目录
    5. /opt 额外安装的可选应用程序包所放置的位置
    6. /proc 虚拟文件系统目录，是系统内存的映射，可直接访问这个目录来获取系统信息
    7. /root 超级用户（系统管理员）的主目录
    8. /sbin 存放二进制可执行文件，只有 root 才能访问
    9. /dev 用于存放设备文件
    10. /mnt 系统管理员按照临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统
    11. /boot 存放用于系统引导时使用的各种文件
    12. /lib 存放跟文件系统中的程序运行所需要的共享库及内核模块
    13. /var 用于存放运行时需要改变数据的文件
2. Linux 文件常用操作
3. Linux 文件类型 // 使用 -a 查看详情时每条的前缀
    1. 套接字（s）
    2. 普通文件（-）
    3. 目录文件（d）
    4. 符号链接（l）
    5. 设备文件（b、c）
    6. FIFO（p）
----------------------------------------------------------------------------------------------
// Linux 文件系统
1. 文件系统概览
    1. FAT // File Allocation Table
        1. FAT16、FAT32等，微软 Dos/Windows 使用的文件系统
        2. 使用一张表保存盘块的信息
    2. NTFS // New Technology File System
        1. WindowsNT 环境的文件系统
        2. NTFS 对 FAT 进行了改进，取代了旧的文件系统
    3. EXT2/3/4 // Extended file system
        1. EXT 是扩展文件系统
        2. Linux 的文件系统
        3. 可以让 windows 或 linux 识别
2. ext 文件系统
----------------------------------------------------------------------------------------------
// 操作系统的设备管理
1. 广义的 IO 设备
    1. 对 cpu 而言，凡是对 cpu 进行数据输入的都是输入设备
    2. 对 cpu 而言，凡是 cpu 进行数据输出的都是输出设备
    3. 按使用特性分类2
        1. 存储设备
            1. u盘
            2. 内存
            3. 磁盘
        2. 交互 IO 设备
            1. 键盘
            2. 显示器
    4. 按设备的共享属性分类
        1. 独占设备
        2. 共享设备
        3. 虚拟设备
    5. 按信息交换的单位分类
        1. 块设备
            1. 磁盘
            2. SD卡
        2. 字符设备
            1. 打印机
            2. Shell 终端
    6. 按传输速率分类
        1. 低速设备
        2. 中速设备
        3. 高速设备
2. IO 设备的缓冲区 //  cpu 与 io 设备的速率不匹配
    1. 减少 cpu 处理 io 请求的频率
    2. 提高 cpu 与 io 设备之间的并行性
    3. 专用缓冲区只适用于特点的 IO 进程
    4. 当这样的 IO 进程比较多时，对内存的消耗也很大
    5. 操作系统划出可供多个进程使用的公共缓冲区，称之为缓冲池
3. SPOOLing 技术
    1. 是关于慢速字符设备如何与计算机主机交换信息的一种技术
    2. 利用高速共享设备将低速的独享设备模拟为高速的共享设备
    3. 逻辑上，系统为每一个用户都分配了一台独立的高速独享设备
    4. 把同步调用低速设备改为异步调用
    5. 在输入、输出之间增加了排队转储环节（输入井、输出井）
    6. 负责输入（出）井与低速设备之间的调度
    7. 逻辑上，进程直接与高速设备交互，减少了进程的等待时间
```